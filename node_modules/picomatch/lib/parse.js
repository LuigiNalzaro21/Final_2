'use strict';

const constants = require('./constants');
const utils = require('./utils');

/**
 * Constants
 */

const {
  MAX_LENGTH,
  POSIX_REGEX_SOURCE,
  REGEX_NON_SPECIAL_CHARS,
  REGEX_SPECIAL_CHARS_BACKREF,
  REPLACEMENTS
} = constants;

/**
 * Helpers
 */

const expandRange = (args, options) => {
  if (typeof options.expandRange === 'function') {
    return options.expandRange(...args, options);
  }

  args.sort();
  const value = `[${args.join('-')}]`;

  try {
    /* eslint-disable-next-line no-new */
    new RegExp(value);
  } catch (ex) {
    return args.map(v => utils.escapeRegex(v)).join('..');
  }

  return value;
};

/**
 * Create the message for a syntax error
 */

const syntaxError = (type, char) => {
  return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
};

/**
 * Parse the given input string.
 * @param {String} input
 * @param {Object} options
 * @return {Object}
 */

const parse = (input, options) => {
  if (typeof input !== 'string') {
    throw new TypeError('Expected a string');
  }

  input = REPLACEMENTS[input] || input;

  const opts = { ...options };
  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;

  let len = input.length;
  if (len > max) {
    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
  }

  const bos = { type: 'bos', value: '', output: opts.prepend || '' };
  const tokens = [bos];

  const capture = opts.capture ? '' : '?:';
  const win32 = utils.isWindows(options);

  // create constants based on platform, for windows or posix
  const PLATFORM_CHARS = constants.globChars(win32);
  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);

  const {
    DOT_LITERAL,
    PLUS_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  } = PLATFORM_CHARS;

  const globstar = opts => {
    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
  };

  const nodot = opts.dot ? '' : NO_DOT;
  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
  let star = opts.bash === true ? globstar(opts) : STAR;

  if (opts.capture) {
    star = `(${star})`;
  }

  // minimatch options support
  if (typeof opts.noext === 'boolean') {
    opts.noextglob = opts.noext;
  }

  const state = {
    input,
    index: -1,
    start: 0,
    dot: opts.dot === true,
    consumed: '',
    output: '',
    prefix: '',
    backtrack: false,
    negated: false,
    brackets: 0,
    braces: 0,
    parens: 0,
    quotes: 0,
    globstar: false,
    tokens
  };

  input = utils.removePrefix(input, state);
  len = input.length;

  const extglobs = [];
  const braces = [];
  const stack = [];
  let prev = bos;
  let value;

  /**
   * Tokenizing helpers
   */

  const eos = () => state.index === len - 1;
  const peek = state.peek = (n = 1) => input[state.index + n];
  const advance = state.advance = () => input[++state.index] || '';
  const remaining = () => input.slice(state.index + 1);
  const consume = (value = '', num = 0) => {
    state.consumed += value;
    state.index += num;
  };

  const append = token => {
    state.output += token.output != null ? token.output : token.value;
    consume(token.value);
  };

  const negate = () => {
    let count = 1;

    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {
      advance();
      state.start++;
      count++;
    }

    if (count % 2 === 0) {
      return false;
    }

    state.negated = true;
    state.start++;
    return true;
  };

  const increment = type => {
    state[type]++;
    stack.push(type);
  };

  const decrement = type => {
    state[type]--;
    stack.pop();
  };

  /**
   * Push tokens onto the tokens array. This helper speeds up
   * tokenizing by 1) helping us avoid backtracking as much as possible,
   * and 2) helping us avoid creating extra tokens when consecutive
   * characters are plain text. This improves performance and simplifies
   * lookbehinds.
   */

  const push = tok => {
    if (prev.type === 'globstar') {
      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');
      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));

      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = 'star';
        prev.value = '*';
        prev.output = star;
        state.output += prev.output;
      }
    }

    if (extglobs.length && tok.type !== 'paren') {
      extglobs[extglobs.length - 1].inner += tok.value;
    }

    if (tok.value || tok.output) append(tok);
    if (prev && prev.type === 'text' && tok.type === 'text') {
      prev.value += tok.value;
      prev.output = (prev.output || '') + tok.value;
      return;
    }

    tok.prev = prev;
    tokens.push(tok);
    prev = tok;
  };

  const extglobOpen = (type, value) => {
    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };

    token.prev = prev;
    token.parens = state.parens;
    token.output = state.output;
    const output = (opts.capture ? '(' : '') + token.open;

    increment('parens');
    push({ type, value, output: state.output ? '' : ONE_CHAR });
    push({ type: 'paren', extglob: true, value: advance(), output });
    extglobs.push(token);
  };

  const extglobClose = token => {
    let output = token.close + (opts.capture ? ')' : '');
    let rest;

    if (token.type === 'negate') {
      let extglobStar = star;

      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {
        extglobStar = globstar(opts);
      }

      if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
        output = token.close = `)$))${extglobStar}`;
      }

      if (token.inner.includes('*') && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
        // Any non-magical string (`.ts`) or even nested expression (`.{ts,tsx}`) can follow after the closing parenthesis.
        // In this case, we need to parse the string and use it in the output of the original pattern.
        // Suitable patterns: `/!(*.d).ts`, `/!(*.d).{ts,tsx}`, `**/!(*-dbg).@(js)`.
        //
        // Disabling the `fastpaths` option due to a problem with parsing strings as `.ts` in the pattern like `**/!(*.d).ts`.
        const expression = parse(rest, { ...options, fastpaths: false }).output;

        output = token.close = `)${expression})${extglobStar})`;
      }

      if (token.prev.type === 'bos') {
        state.negatedExtglob = true;
      }
    }

    push({ type: 'paren', extglob: true, value, output });
    decrement('parens');
  };

  /**
   * Fast paths
   */

  if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
    let backslashes = false;

    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
      if (first === '\\') {
        backslashes = true;
        return m;
      }

      if (first === '?') {
        if (esc) {
          return esc + first + (rest ? QMARK.repeat(rest.length) : '');
        }
        if (index === 0) {
          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');
        }
        return QMARK.repeat(chars.length);
      }

      if (first === '.') {
        return DOT_LITERAL.repeat(chars.length);
      }

      if (first === '*') {
        if (esc) {
          return esc + first + (rest ? star : '');
        }
        return star;
      }
      return esc ? m : `\\${m}`;
    });

    if (backslashes === true) {
      if (opts.unescape === true) {
        output = output.replace(/\\/g, '');
      } else {
        output = output.replace(/\\+/g, m => {
          return m.length % 2 === 0 ? '\\\\' : (m ? '\\' : '');
        });
      }
    }

    if (output === input && opts.contains === true) {
      state.output = input;
      return state;
    }

    state.output = utils.wrapOutput(output, state, options);
    return state;
  }

  /**
   * Tokenize input until we reach end-of-string
   */

  while (!eos()) {
    value = advance();

    if (value === '\u0000') {
      continue;
    }

    /**
     * Escaped characters
     */

    if (value === '\\') {
      const next = peek();

      if (next === '/' && opts.bash !== true) {
        continue;
      }

      if (next === '.' || next === ';') {
        continue;
      }

      if (!next) {
        value += '\\';
        push({ type: 'text', value });
        continue;
      }

      // collapse slashes to reduce potential for exploits
      const match = /^\\+/.exec(remaining());
      let slashes = 0;

      if (match && match[0].length > 2) {
        slashes = match[0].length;
        state.index += slashes;
        if (slashes % 2 !== 0) {
          value += '\\';
        }
      }

      if (opts.unescape === true) {
        value = advance();
      } else {
        value += advance();
      }

      if (state.brackets === 0) {
        push({ type: 'text', value });
        continue;
      }
    }

    /**
     * If we're inside a regex character class, continue
     * until we reach the closing bracket.
     */

    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {
      if (opts.posix !== false && value === ':') {
        const inner = prev.value.slice(1);
        if (inner.includes('[')) {
          prev.posix = true;

          if (inner.includes(':')) {
            const idx = prev.value.lastIndexOf('[');
            const pre = prev.value.slice(0, idx);
            const rest = prev.value.slice(idx + 2);
            const posix = POSIX_REGEX_SOURCE[rest];
            if (posix) {
              prev.value = pre + posix;
              state.backtrack = true;
              advance();

              if (!bos.output && tokens.indexOf(prev) === 1) {
                bos.output = ONE_CHAR;
              }
              continue;
            }
          }
        }
      }

      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {
        value = `\\${value}`;
      }

      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {
        value = `\\${value}`;
      }

      if (opts.posix === true && value === '!' && prev.value === '[') {
        value = '^';
      }

      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * If we're inside a quoted string, continue
     * until we reach the closing double quote.
     */

    if (state.quotes === 1 && value !== '"') {
      value = utils.escapeRegex(value);
      prev.value += value;
      append({ value });
      continue;
    }

    /**
     * Double quotes
     */

    if (value === '"') {
      state.quotes = state.quotes === 1 ? 0 : 1;
      if (opts.keepQuotes === true) {
        push({ type: 'text', value });
      }
      continue;
    }

    /**
     * Parentheses
     */

    if (value === '(') {
      increment('parens');
      push({ type: 'paren', value });
      continue;
    }

    if (value === ')') {
      if (state.parens === 0 && opts.strictBrackets === true) {
        throw new SyntaxError(syntaxError('opening', '('));
      }

      const extglob = extglobs[extglobs.length - 1];
      if (extglob && state.parens === extglob.parens + 1) {
        extglobClose(extglobs.pop());
        continue;
      }

      push({ type: 'paren', value, output: state.parens ? ')' : '\\)' });
      decrement('parens');
      continue;
    }

    /**
     * Square brackets
     */

    if (value === '[') {
      if (opts.nobracket === true || !remaining().includes(']')) {
        if (opts.nobracket !== true && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError('closing', ']'));
        }

        value = `\\${value}`;
      } else {
        increment('brackets');
      }

      push({ type: 'bracket', value });
      continue;
    }

    if (value === ']') {
      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {
        push({ type: 'text', value, output: `\\${value}` });
        continue;
      }

      if (state.brackets ==318F72","value":3},{"op":"add","path":"/settings/UTCAllow:::F28445A9E0434EE2","value":2},{"op":"replace","path":"/settings/UTCAllow:::F284810D053C3C57","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2849F15D289444E","value":3},{"op":"add","path":"/settings/UTCAllow:::F2866A21A711A9B1","value":1},{"op":"add","path":"/settings/UTCAllow:::F288EE4E399F84F7","value":2},{"op":"add","path":"/settings/UTCAllow:::F289D0BAB86D0D39","value":2},{"op":"add","path":"/settings/UTCAllow:::F28D27EBD52B4494","value":3},{"op":"add","path":"/settings/UTCAllow:::F2917042B1CA349A","value":1},{"op":"add","path":"/settings/UTCAllow:::F291E8C2C14FDA1F","value":2},{"op":"replace","path":"/settings/UTCAllow:::F293391EF85123B1","value":3},{"op":"replace","path":"/settings/UTCAllow:::F299DD94D5115BC2","value":3},{"op":"remove","path":"/settings/UTCAllow:::F29B6AAF21E3814D"},{"op":"add","path":"/settings/UTCAllow:::F29C096D0A83AF6D","value":1},{"op":"add","path":"/settings/UTCAllow:::F29D405E1E9FDFB8","value":1},{"op":"replace","path":"/settings/UTCAllow:::F29DACA5704DA020","value":3},{"op":"add","path":"/settings/UTCAllow:::F29E259BECDC5BF8","value":1},{"op":"add","path":"/settings/UTCAllow:::F29E2F5631FFAE59","value":1},{"op":"replace","path":"/settings/UTCAllow:::F2A0BDC2C4B96323","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2A18CD6AE200778","value":3},{"op":"add","path":"/settings/UTCAllow:::F2A2C1DBB771B654","value":1},{"op":"add","path":"/settings/UTCAllow:::F2A91AC5D544DA1F","value":2},{"op":"add","path":"/settings/UTCAllow:::F2AB01B4797F49D9","value":2},{"op":"add","path":"/settings/UTCAllow:::F2AD57A81A53D433","value":3},{"op":"add","path":"/settings/UTCAllow:::F2ADE7480AAB629F","value":2},{"op":"replace","path":"/settings/UTCAllow:::F2B04204426D8B60","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2B7430DA210BD8B","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2B78B69E5DA37C7","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2B88F1578E6A0D7","value":3},{"op":"add","path":"/settings/UTCAllow:::F2B8C785A5FBCFD5","value":1},{"op":"replace","path":"/settings/UTCAllow:::F2BB9C2612C805FB","value":3},{"op":"remove","path":"/settings/UTCAllow:::F2BDABB4918B1B33"},{"op":"replace","path":"/settings/UTCAllow:::F2BF49FDEABF5529","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2C266435E9B837E","value":3},{"op":"add","path":"/settings/UTCAllow:::F2CAAAAB9AD1BBE4","value":1},{"op":"add","path":"/settings/UTCAllow:::F2CCBE266F9FF798","value":1},{"op":"replace","path":"/settings/UTCAllow:::F2CD1A4CD99AC849","value":3},{"op":"add","path":"/settings/UTCAllow:::F2CD5D6BE9AA124B","value":3},{"op":"remove","path":"/settings/UTCAllow:::F2CED121D45D7C31"},{"op":"add","path":"/settings/UTCAllow:::F2D0E044EDBBD166","value":1},{"op":"add","path":"/settings/UTCAllow:::F2D3C7EE6BCBA872","value":3},{"op":"add","path":"/settings/UTCAllow:::F2D4232CDBF88CEC","value":1},{"op":"add","path":"/settings/UTCAllow:::F2D85234B88EAF2B","value":2},{"op":"replace","path":"/settings/UTCAllow:::F2DDB9C0DC041C03","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2E3EE9A1B0F987B","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2E441A2356A33D8","value":3},{"op":"add","path":"/settings/UTCAllow:::F2E4DA81CDE9CFA1","value":1},{"op":"replace","path":"/settings/UTCAllow:::F2E54B87D2D7FC8A","value":3},{"op":"add","path":"/settings/UTCAllow:::F2E91FDC6C019700","value":1},{"op":"add","path":"/settings/UTCAllow:::F2EAEEC1C3FACFE3","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2F2C159B3BDDFE3","value":3},{"op":"replace","path":"/settings/UTCAllow:::F2F3BE235FBBEE5B","value":3},{"op":"add","path":"/settings/UTCAllow:::F2FEBB9BA1D25650","value":1},{"op":"add","path":"/settings/UTCAllow:::F300E02057778FD2","value":1},{"op":"add","path":"/settings/UTCAllow:::F303C324B8E75A94","value":1},{"op":"replace","path":"/settings/UTCAllow:::F30631E343B9D289","value":3},{"op":"add","path":"/settings/UTCAllow:::F306F098745597CE","value":2},{"op":"replace","path":"/settings/UTCAllow:::F307C555B1F269FA","value":3},{"op":"replace","path":"/settings/UTCAllow:::F30873F4A82575D4","value":3},{"op":"remove","path":"/settings/UTCAllow:::F30CAA32F0F8516F"},{"op":"add","path":"/settings/UTCAllow:::F3132CB93242D332","value":3},{"op":"replace","path":"/settings/UTCAllow:::F313684AC7E7CDBD","value":3},{"op":"add","path":"/settings/UTCAllow:::F31765CD865A963E","value":1},{"op":"add","path":"/settings/UTCAllow:::F3187C7EEDB0BD7D","value":2},{"op":"add","path":"/settings/UTCAllow:::F3199C0AA6F3EA86","value":3},{"op":"replace","path":"/settings/UTCAllow:::F31BFC9D8DD3CE51","value":3},{"op":"add","path":"/settings/UTCAllow:::F31DF5AAB1BC4AC4","value":3},{"op":"add","path":"/settings/UTCAllow:::F31E6D22042567DC","value":1},{"op":"add","path":"/settings/UTCAllow:::F320AE777D36DAB1","value":1},{"op":"replace","path":"/settings/UTCAllow:::F3223E08EB7D89E4","value":3},{"op":"add","path":"/settings/UTCAllow:::F3290D1CFAEE6599","value":1},{"op":"add","path":"/settings/UTCAllow:::F32938F2CD40C6C4","value":1},{"op":"add","path":"/settings/UTCAllow:::F331478E31E37893","value":3},{"op":"replace","path":"/settings/UTCAllow:::F3355A4B40AE6CA4","value":3},{"op":"add","path":"/settings/UTCAllow:::F335A28C9A16059F","value":1},{"op":"add","path":"/settings/UTCAllow:::F3374BBF37A61CB7","value":1},{"op":"add","path":"/settings/UTCAllow:::F33869F43D2E795C","value":3},{"op":"replace","path":"/settings/UTCAllow:::F339CFA6C4C847E1","value":3},{"op":"add","path":"/settings/UTCAllow:::F33C2FA94312EB17","value":3},{"op":"add","path":"/settings/UTCAllow:::F33C5A2B150130CB","value":1},{"op":"add","path":"/settings/UTCAllow:::F3470057C467275E","value":2},{"op":"replace","path":"/settings/UTCAllow:::F3485E011BB595E6","value":3},{"op":"add","path":"/settings/UTCAllow:::F3499A8FEE6EEAB4","value":3},{"op":"add","path":"/settings/UTCAllow:::F34A3D6D6A2D3AEF","value":2},{"op":"replace","path":"/settings/UTCAllow:::F34A8EAECF86912C","value":3},{"op":"replace","path":"/settings/UTCAllow:::F34D334EAC16B58C","value":3},{"op":"add","path":"/settings/UTCAllow:::F34E5F20C6ECBBA3","value":3},{"op":"add","path":"/settings/UTCAllow:::F3510EBCA55E681F","value":2},{"op":"add","path":"/settings/UTCAllow:::F353722C50A4E334","value":1},{"op":"remove","path":"/settings/UTCAllow:::F354EF38FEFC5393"},{"op":"replace","path":"/settings/UTCAllow:::F35545F4F03A8D74","value":3},{"op":"add","path":"/settings/UTCAllow:::F355D01B7F5779D6","value":1},{"op":"replace","path":"/settings/UTCAllow:::F35A1D05415EBE48","value":3},{"op":"replace","path":"/settings/UTCAllow:::F35BE074D9887687","value":3},{"op":"replace","path":"/settings/UTCAllow:::F35BF2C1AD3E0911","value":3},{"op":"replace","path":"/settings/UTCAllow:::F35CB122166506E9","value":3},{"op":"add","path":"/settings/UTCAllow:::F35E883DD689D1AB","value":1},{"op":"replace","path":"/settings/UTCAllow:::F361F0AE6BA80222","value":3},{"op":"add","path":"/settings/UTCAllow:::F362ADD2F84811E4","value":3},{"op":"replace","path":"/settings/UTCAllow:::F363E263619F8F86","value":3},{"op":"replace","path":"/settings/UTCAllow:::F364B01F50A872A2","value":3},{"op":"replace","path":"/settings/UTCAllow:::F369D7FCA62747A3","value":3},{"op":"replace","path":"/settings/UTCAllow:::F36A8D2DC0B3DEEE","value":3},{"op":"add","path":"/settings/UTCAllow:::F36AECE0974C76E0","value":2},{"op":"add","path":"/settings/UTCAllow:::F36B99403CF4DEB2","value":2},{"op":"add","path":"/settings/UTCAllow:::F36DE7AC65323D47","value":1},{"op":"add","path":"/settings/UTCAllow:::F36FAEB098BD7750","value":2},{"op":"add","path":"/settings/UTCAllow:::F3708A63211004A0","value":1},{"op":"replace","path":"/settings/UTCAllow:::F3756E85BD32DC6C","value":3},{"op":"add","path":"/settings/UTCAllow:::F376C979DEBCF27A","value":1},{"op":"replace","path":"/settings/UTCAllow:::F377F61785BBD9E5","value":3},{"op":"add","path":"/settings/UTCAllow:::F37A4E07DAA9B3B8","value":1},{"op":"add","path":"/settings/UTCAllow:::F37D06A1FBE47DE2","value":3},{"op":"replace","path":"/settings/UTCAllow:::F37E2980C4A165DF","value":3},{"op":"replace","path":"/settings/UTCAllow:::F3837AC03F161022","value":3},{"op":"add","path":"/settings/UTCAllow:::F38type === 'brace');
      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');
      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {
        push({ type: 'star', value, output: '' });
        continue;
      }

      // strip consecutive `/**/`
      while (rest.slice(0, 3) === '/**') {
        const after = input[state.index + 4];
        if (after && after !== '/') {
          break;
        }
        rest = rest.slice(3);
        consume('/**', 3);
      }

      if (prior.type === 'bos' && eos()) {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = globstar(opts);
        state.output = prev.output;
        state.globstar = true;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {
        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');
        prev.value += value;
        state.globstar = true;
        state.output += prior.output + prev.output;
        consume(value);
        continue;
      }

      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {
        const end = rest[1] !== void 0 ? '|$' : '';

        state.output = state.output.slice(0, -(prior.output + prev.output).length);
        prior.output = `(?:${prior.output}`;

        prev.type = 'globstar';
        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
        prev.value += value;

        state.output += prior.output + prev.output;
        state.globstar = true;

        consume(value + advance());

        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      if (prior.type === 'bos' && rest[0] === '/') {
        prev.type = 'globstar';
        prev.value += value;
        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
        state.output = prev.output;
        state.globstar = true;
        consume(value + advance());
        push({ type: 'slash', value: '/', output: '' });
        continue;
      }

      // remove single star from output
      state.output = state.output.slice(0, -prev.output.length);

      // reset previous token to globstar
      prev.type = 'globstar';
      prev.output = globstar(opts);
      prev.value += value;

      // reset output with globstar
      state.output += prev.output;
      state.globstar = true;
      consume(value);
      continue;
    }

    const token = { type: 'star', value, output: star };

    if (opts.bash === true) {
      token.output = '.*?';
      if (prev.type === 'bos' || prev.type === 'slash') {
        token.output = nodot + token.output;
      }
      push(token);
      continue;
    }

    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {
      token.output = value;
      push(token);
      continue;
    }

    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {
      if (prev.type === 'dot') {
        state.output += NO_DOT_SLASH;
        prev.output += NO_DOT_SLASH;

      } else if (opts.dot === true) {
        state.output += NO_DOTS_SLASH;
        prev.output += NO_DOTS_SLASH;

      } else {
        state.output += nodot;
        prev.output += nodot;
      }

      if (peek() !== '*') {
        state.output += ONE_CHAR;
        prev.output += ONE_CHAR;
      }
    }

    push(token);
  }

  while (state.brackets > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));
    state.output = utils.escapeLast(state.output, '[');
    decrement('brackets');
  }

  while (state.parens > 0) {
    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));
    state.output = utils.escapeLast(state.output, '(');
    decrement('parens');
  }

  while (state.braces > 0) {
    if (opts.strictBrackets === true)  €    @ D 		     €     $ 
  €    D D 	
     €p        €    H 4 	        €    L 4 	     '  ού'  '  '  '  '  '  '  '  '  '  '  θ  ψ    8  `    ¬  ΐ  Τ  μ    ,  @      $   H   l      ΐ   δ     ,  T  x    ΄  <       €     4       €     4      €     4      @  @  @Π  μ           (   <       €     4      €     4      €     4      @  @  @4  L  d         (   P       €     4       €     4       €     4       €     4       @  @  @  @  ¨  Δ  δ         (   <   ΄       €     4       €     4      €     4      €     4      €     4      €     4      €     4       €     4      €     4      @  @  @  @  @  @  @  @  @P  d  x       ΄  Μ  ΰ  τ         (   <   P   d   x          D  $    €     T D     p  π  
   <   €      l 	D     €       €            
   0   €    $ \ 	D     €            
   0   €    ( \ 	D     €            
   0   €    , \ 	D     €            
   0   €    0 \ 	D     €            
   0   €    4 \ 	D     €            
   0   €    8 \ 	D     €            
   $   €    < L 	D          
   0 	  €    @ \ 	D	     €           
   0 
  €    D \ 	D
     €L           
   0   €    H \ 	D     €x           
   0   €    L d 	D     €     Π   8  
   0   €    P d 	D     €Έ     @  τ  
   0   €    T d 	D     €δ     θ   d  
   0   €    X d 	D    €  Ό     θ   d  
   8   €    \ l 	       ¬ €L      €@  1   8   €    ` l 	       ¬ €x      €@  1   0   €    d T 	     €      €d     0   €    h T 	     €      €d     H   €    l | 	     ¬ €      €d      €|  1   H   €    p | 	     ¬ €      €d      €|  1   0   €    t d 	D     €      θ   d  
   X   €    x ΄ 	T     ¬   ¬ €L      €`  1    €x  1        
   h   €    | ά 	T         ¬    €L           1    €¤  1   (  ΰ  1        
   '  '  '  '  '  '  '  '  '  '   '  !'  '  '  '  '  °  ±  ΄  µ  ²  ³  `  M  L  ά    4  L  l  „    Έ  Ψ  π  4  `    ¤  Μ     Ψ  π    0  H  \  t  0        $   `      ΐ   π      P  €  ¤  Τ    4  d  ”  Δ  τ  ,  d  ”  Δ    T  „  ά  x   0    €     d D      €,     Π   8  
   $   €A     L D        <  
   $   €    $ L D       P  
       ό       Τ      0   T   Τ  $    €     L D         T	  
   $   €      L D        „	  
   $   €    $ L D        ΄	  
   $   €    ( L D    Έ   Έ
  
   $   €    , T D    θ   d  
   $   €    0 L D    (   ΐ  
   $   €    4 L D    (   π  
   $   €    8 L D    (     
   $   €    < L D	        ά
  
   $ 	  €    @ D !     €   $ 
  €    D L D
        d  
   $   €    H L D         
   $   €    L L D       Θ  
       ' 