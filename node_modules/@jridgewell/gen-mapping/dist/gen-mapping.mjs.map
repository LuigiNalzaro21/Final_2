{"version":3,"file":"gen-mapping.mjs","sources":["../src/sourcemap-segment.ts","../src/gen-mapping.ts"],"sourcesContent":["type GeneratedColumn = number;\ntype SourcesIndex = number;\ntype SourceLine = number;\ntype SourceColumn = number;\ntype NamesIndex = number;\n\nexport type SourceMapSegment =\n  | [GeneratedColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn]\n  | [GeneratedColumn, SourcesIndex, SourceLine, SourceColumn, NamesIndex];\n\nexport const COLUMN = 0;\nexport const SOURCES_INDEX = 1;\nexport const SOURCE_LINE = 2;\nexport const SOURCE_COLUMN = 3;\nexport const NAMES_INDEX = 4;\n","import { SetArray, put, remove } from '@jridgewell/set-array';\nimport { encode } from '@jridgewell/sourcemap-codec';\nimport { TraceMap, decodedMappings } from '@jridgewell/trace-mapping';\n\nimport {\n  COLUMN,\n  SOURCES_INDEX,\n  SOURCE_LINE,\n  SOURCE_COLUMN,\n  NAMES_INDEX,\n} from './sourcemap-segment';\n\nimport type { SourceMapInput } from '@jridgewell/trace-mapping';\nimport type { SourceMapSegment } from './sourcemap-segment';\nimport type { DecodedSourceMap, EncodedSourceMap, Pos, Mapping } from './types';\n\nexport type { DecodedSourceMap, EncodedSourceMap, Mapping };\n\nexport type Options = {\n  file?: string | null;\n  sourceRoot?: string | null;\n};\n\nconst NO_NAME = -1;\n\n/**\n * Provides the state to generate a sourcemap.\n */\nexport class GenMapping {\n  private declare _names: SetArray<string>;\n  private declare _sources: SetArray<string>;\n  private declare _sourcesContent: (string | null)[];\n  private declare _mappings: SourceMapSegment[][];\n  private declare _ignoreList: SetArray<number>;\n  declare file: string | null | undefined;\n  declare sourceRoot: string | null | undefined;\n\n  constructor({ file, sourceRoot }: Options = {}) {\n    this._names = new SetArray();\n    this._sources = new SetArray();\n    this._sourcesContent = [];\n    this._mappings = [];\n    this.file = file;\n    this.sourceRoot = sourceRoot;\n    this._ignoreList = new SetArray();\n  }\n}\n\ninterface PublicMap {\n  _names: GenMapping['_names'];\n  _sources: GenMapping['_sources'];\n  _sourcesContent: GenMapping['_sourcesContent'];\n  _mappings: GenMapping['_mappings'];\n  _ignoreList: GenMapping['_ignoreList'];\n}\n\n/**\n * Typescript doesn't allow friend access to private fields, so this just casts the map into a type\n * with public access modifiers.\n */\nfunction cast(map: unknown): PublicMap {\n  return map as any;\n}\n\n/**\n * A low-level API to associate a generated position with an original source position. Line and\n * column here are 0-based, unlike `addMapping`.\n */\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: null,\n  sourceLine?: null,\n  sourceColumn?: null,\n  name?: null,\n  content?: null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name?: null,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: string,\n  sourceLine: number,\n  sourceColumn: number,\n  name: string,\n  content?: string | null,\n): void;\nexport function addSegment(\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source?: string | null,\n  sourceLine?: number | null,\n  sourceColumn?: number | null,\n  name?: string | null,\n  content?: string | null,\n): void {\n  return addSegmentInternal(\n    false,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n}\n\n/**\n * A high-level API to associate a generated position with an original source position. Line is\n * 1-based, but column is 0-based, due to legacy behavior in `source-map` library.\n */\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: null;\n    original?: null;\n    name?: null;\n    content?: null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name?: null;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: string;\n    original: Pos;\n    name: string;\n    content?: string | null;\n  },\n): void;\nexport function addMapping(\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source?: string | null;\n    original?: Pos | null;\n    name?: string | null;\n    content?: string | null;\n  },\n): void {\n  return addMappingInternal(false, map, mapping as Parameters<typeof addMappingInternal>[2]);\n}\n\n/**\n * Same as `addSegment`, but will only add the segment if it generates useful information in the\n * resulting map. This only works correctly if segments are added **in order**, meaning you should\n * not add a segment with a lower generated line/column than one that came before.\n */\nexport const maybeAddSegment: typeof addSegment = (\n  map,\n  genLine,\n  genColumn,\n  source,\n  sourceLine,\n  sourceColumn,\n  name,\n  content,\n) => {\n  return addSegmentInternal(\n    true,\n    map,\n    genLine,\n    genColumn,\n    source,\n    sourceLine,\n    sourceColumn,\n    name,\n    content,\n  );\n};\n\n/**\n * Same as `addMapping`, but will only add the mapping if it generates useful information in the\n * resulting map. This only works correctly if mappings are added **in order**, meaning you should\n * not add a mapping with a lower generated line/column than one that came before.\n */\nexport const maybeAddMapping: typeof addMapping = (map, mapping) => {\n  return addMappingInternal(true, map, mapping as Parameters<typeof addMappingInternal>[2]);\n};\n\n/**\n * Adds/removes the content of the source file to the source map.\n */\nexport function setSourceContent(map: GenMapping, source: string, content: string | null): void {\n  const { _sources: sources, _sourcesContent: sourcesContent } = cast(map);\n  const index = put(sources, source);\n  sourcesContent[index] = content;\n}\n\nexport function setIgnore(map: GenMapping, source: string, ignore = true) {\n  const { _sources: sources, _sourcesContent: sourcesContent, _ignoreList: ignoreList } = cast(map);\n  const index = put(sources, source);\n  if (index === sourcesContent.length) sourcesContent[index] = null;\n  if (ignore) put(ignoreList, index);\n  else remove(ignoreList, index);\n}\n\n/**\n * Returns a sourcemap object (with decoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toDecodedMap(map: GenMapping): DecodedSourceMap {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n    _ignoreList: ignoreList,\n  } = cast(map);\n  removeEmptyFinalLines(mappings);\n\n  return {\n    version: 3,\n    file: map.file || undefined,\n    names: names.array,\n    sourceRoot: map.sourceRoot || undefined,\n    sources: sources.array,\n    sourcesContent,\n    mappings,\n    ignoreList: ignoreList.array,\n  };\n}\n\n/**\n * Returns a sourcemap object (with encoded mappings) suitable for passing to a library that expects\n * a sourcemap, or to JSON.stringify.\n */\nexport function toEncodedMap(map: GenMapping): EncodedSourceMap {\n  const decoded = toDecodedMap(map);\n  return {\n    ...decoded,\n    mappings: encode(decoded.mappings as SourceMapSegment[][]),\n  };\n}\n\n/**\n * Constructs a new GenMapping, using the already present mappings of the input.\n */\nexport function fromMap(input: SourceMapInput): GenMapping {\n  const map = new TraceMap(input);\n  const gen = new GenMapping({ file: map.file, sourceRoot: map.sourceRoot });\n\n  putAll(cast(gen)._names, map.names);\n  putAll(cast(gen)._sources, map.sources as string[]);\n  cast(gen)._sourcesContent = map.sourcesContent || map.sources.map(() => null);\n  cast(gen)._mappings = decodedMappings(map) as GenMapping['_mappings'];\n  if (map.ignoreList) putAll(cast(gen)._ignoreList, map.ignoreList);\n\n  return gen;\n}\n\n/**\n * Returns an array of high-level mapping objects for every recorded segment, which could then be\n * passed to the `source-map` library.\n */\nexport function allMappings(map: GenMapping): Mapping[] {\n  const out: Mapping[] = [];\n  const { _mappings: mappings, _sources: sources, _names: names } = cast(map);\n\n  for (let i = 0; i < mappings.length; i++) {\n    const line = mappings[i];\n    for (let j = 0; j < line.length; j++) {\n      const seg = line[j];\n\n      const generated = { line: i + 1, column: seg[COLUMN] };\n      let source: string | undefined = undefined;\n      let original: Pos | undefined = undefined;\n      let name: string | undefined = undefined;\n\n      if (seg.length !== 1) {\n        source = sources.array[seg[SOURCES_INDEX]];\n        original = { line: seg[SOURCE_LINE] + 1, column: seg[SOURCE_COLUMN] };\n\n        if (seg.length === 5) name = names.array[seg[NAMES_INDEX]];\n      }\n\n      out.push({ generated, source, original, name } as Mapping);\n    }\n  }\n\n  return out;\n}\n\n// This split declaration is only so that terser can elminiate the static initialization block.\nfunction addSegmentInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  genLine: number,\n  genColumn: number,\n  source: S,\n  sourceLine: S extends string ? number : null | undefined,\n  sourceColumn: S extends string ? number : null | undefined,\n  name: S extends string ? string | null | undefined : null | undefined,\n  content: S extends string ? string | null | undefined : null | undefined,\n): void {\n  const {\n    _mappings: mappings,\n    _sources: sources,\n    _sourcesContent: sourcesContent,\n    _names: names,\n  } = cast(map);\n  const line = getLine(mappings, genLine);\n  const index = getColumnIndex(line, genColumn);\n\n  if (!source) {\n    if (skipable && skipSourceless(line, index)) return;\n    return insert(line, index, [genColumn]);\n  }\n\n  // Sigh, TypeScript can't figure out sourceLine and sourceColumn aren't nullish if source\n  // isn't nullish.\n  assert<number>(sourceLine);\n  assert<number>(sourceColumn);\n\n  const sourcesIndex = put(sources, source);\n  const namesIndex = name ? put(names, name) : NO_NAME;\n  if (sourcesIndex === sourcesContent.length) sourcesContent[sourcesIndex] = content ?? null;\n\n  if (skipable && skipSource(line, index, sourcesIndex, sourceLine, sourceColumn, namesIndex)) {\n    return;\n  }\n\n  return insert(\n    line,\n    index,\n    name\n      ? [genColumn, sourcesIndex, sourceLine, sourceColumn, namesIndex]\n      : [genColumn, sourcesIndex, sourceLine, sourceColumn],\n  );\n}\n\nfunction assert<T>(_val: unknown): asserts _val is T {\n  // noop.\n}\n\nfunction getLine(mappings: SourceMapSegment[][], index: number): SourceMapSegment[] {\n  for (let i = mappings.length; i <= index; i++) {\n    mappings[i] = [];\n  }\n  return mappings[index];\n}\n\nfunction getColumnIndex(line: SourceMapSegment[], genColumn: number): number {\n  let index = line.length;\n  for (let i = index - 1; i >= 0; index = i--) {\n    const current = line[i];\n    if (genColumn >= current[COLUMN]) break;\n  }\n  return index;\n}\n\nfunction insert<T>(array: T[], index: number, value: T) {\n  for (let i = array.length; i > index; i--) {\n    array[i] = array[i - 1];\n  }\n  array[index] = value;\n}\n\nfunction removeEmptyFinalLines(mappings: SourceMapSegment[][]) {\n  const { length } = mappings;\n  let len = length;\n  for (let i = len - 1; i >= 0; len = i, i--) {\n    if (mappings[i].length > 0) break;\n  }\n  if (len < length) mappings.length = len;\n}\n\nfunction putAll<T extends string | number>(setarr: SetArray<T>, array: T[]) {\n  for (let i = 0; i < array.length; i++) put(setarr, array[i]);\n}\n\nfunction skipSourceless(line: SourceMapSegment[], index: number): boolean {\n  // The start of a line is already sourceless, so adding a sourceless segment to the beginning\n  // doesn't generate any useful information.\n  if (index === 0) return true;\n\n  const prev = line[index - 1];\n  // If the previous segment is also sourceless, then adding another sourceless segment doesn't\n  // genrate any new information. Else, this segment will end the source/named segment and point to\n  // a sourceless position, which is useful.\n  return prev.length === 1;\n}\n\nfunction skipSource(\n  line: SourceMapSegment[],\n  index: number,\n  sourcesIndex: number,\n  sourceLine: number,\n  sourceColumn: number,\n  namesIndex: number,\n): boolean {\n  // A source/named segment at the start of a line gives position at that genColumn\n  if (index === 0) return false;\n\n  const prev = line[index - 1];\n\n  // If the previous segment is sourceless, then we're transitioning to a source.\n  if (prev.length === 1) return false;\n\n  // If the previous segment maps to the exact same source position, then this segment doesn't\n  // provide any new position information.\n  return (\n    sourcesIndex === prev[SOURCES_INDEX] &&\n    sourceLine === prev[SOURCE_LINE] &&\n    sourceColumn === prev[SOURCE_COLUMN] &&\n    namesIndex === (prev.length === 5 ? prev[NAMES_INDEX] : NO_NAME)\n  );\n}\n\nfunction addMappingInternal<S extends string | null | undefined>(\n  skipable: boolean,\n  map: GenMapping,\n  mapping: {\n    generated: Pos;\n    source: S;\n    original: S extends string ? Pos : null | undefined;\n    name: S extends string ? string | null | undefined : null | undefined;\n    content: S extends string ? string | null | undefined : null | undefined;\n  },\n) {\n  const { generated, source, original, name, content } = mapping;\n  if (!source) {\n    return addSegmentInternal(\n      skipable,\n      map,\n      generated.line - 1,\n      generated.column,\n      null,\n      null,\n      null,\n      null,\n      null,\n    );\n  }\n  assert<Pos>(original);\n  return addSegmentInternal(\n    skipable,\n    map,\n    generated.line - 1,\n    generated.column,\n    source as string,\n    original.line - 1,\n    original.column,\n    name,\n    content,\n  );\n}\n"],"names":[],"mappings":"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…öx WQ‹ôşÿÿºş>@ è)ÿÿÿÿµôşÿÿ‹ğÿD A ‹Mü‹Æ_3Í^è¾¯ÿÿÉÃ‹ÿU‹ì‹E3É…Àt=ÿÿÿv¹W €…ÉxM‹ĞQÿuQ‹Mè   ‹Èë
…Àt‹EÆ  ‹Á]Ã‹ÿU‹ìSVWÿurÿ‹ùÿu3ÛVWÿÈ¢A ƒÄ…Àx;Æwuˆ>ëˆ>»z €_^‹Ã[]Â ‹ÿU‹ìƒì0¡@‘A 3Å‰EøS‹]‹Á‹MVWƒ# ‹ò‰EÔ‰MĞ}è¥¥¥¥‹ôj SQMèQ‹Èÿğ¢A ÿUÔ;ôt¹   Í)‹ğ…öxAƒ; t<3À}Ø««««EØPEèPÿ˜¡A …Àu!jEØPEèPè¢²ÿÿƒÄ…Àt‹EÔuØ‹MĞë’‹Mø‹Æ_^3Í[è•®ÿÿÉÂ ‹ÿS‹Ù¹p”A VWÇP@ ¡p”A ë	;ÃtH‹…Àuóë‹@‰‹K…Ét@‹‹üÿsQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹C‹üP‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)‹K…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹K…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)ÿsÿü¡A _^[Ã‹ÿU‹ìƒì3À‰MôSV‰EğMğ‰Eü‰Eø‹EW‹üQ‹0h¤;@ P‹ÿğ¢A ÿ;üt¹   Í)‹Ø…Ûˆ  ‹EMø‹üQP‹0‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…Ûˆä   ‹MôUü‹uøƒÁ ‹Eğ‹ù¥¥¥¥‹0‹üRQP‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…Ûˆ§   ‹Uô‹ü‹MüB‹1PRQ‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…ÛxzÿuÿÀ¡A ‹]ô‰C…Àu» €ë`‹M‹ü‹Eüƒeü ‰K‰C‹Q‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹M‹ü‰KQ‹‹p‹Îÿğ¢A ÿÖ;üt¹   Í)¡p”A ‰C‰p”A 3Ûƒ}ø t#‹M‹üÿuøQ‹‹pL‹Îÿğ¢A ÿÖ;üt¹   Í)‹Mğ…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹Mü…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)_^‹Ã[ÉÂ ‹ÿU‹ìƒìS‹Â3ÒV‹1W‰Eğ‹ü‰EøPhÔ;@ Q‹‰Uø‰Uüÿğ¢A ÿ;üt¹   Í)‰Eô…Àˆ†   ‹p”A ‹Mü…Ûte…Ét!‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)ƒeü ‹CMü‹üQhÔ;@ ‹0P‹ÿğ¢A ÿ;üt¹   Í)‰Eô…Àx'‹Uø‹Mü;Ñt‹[…Ûuë‹Uø‹Eğ‰3À…Û”À‰Eôë‹Uø‹Mü…Òt ‹‹üR‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹Mü…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹Eô_^[ÉÃÌÌÌ‹ÿU‹ìƒ} t#ƒ} t‹Mºä;@ èı—ÿÿ÷ØÀ%ª?ùÿW €ë¸@ €]Â ÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒì4‹Mºä;@ S3ÛVW‰]Ì‰]Ğ‰]Ô‰]Ø‰]ø‰]ô‰]ğè¬—ÿÿ…Àu
¾W €é9  ‹EMÜ‹üQj‹@MøQÿu‹0P‹Nÿğ¢A ÿV;üt¹   Í)‹ğ‰uü…öˆ{  9]Üu¾ÿÿ €‰uüéi  ‹}‹W…ÒtJf‹ƒÂf;Ãuõ+ÑÑúë‹Ó‹Mø…Étqf‹ƒÁf;Ãuõ+ÎÑùë‹Ë4VSÿĞ¡A ‰Eô…Àu¾ €ë¢ÿwFVÿuôÿ ¢A ÿuøVÿuôÿ¨¢A ‹l”A EğƒÄPè	  ‹ğ‰uü…öˆÙ  ‹EğMà‹ü‰]àQÿu‹0MôjQhä;@ ‹NPÿğ¢A ÿV;üt¹   Í)‹ğ‰uü…öyş €…  ‹óéÿÿÿ‹M‹Q…Òt‹A8›ıÿÿu‰Mäé&  EÌ‰Eä‹AJ‰MØ@3É‰EÔjZ÷âÁ÷ÙÈQè±¨ÿÿ‰EÌY…Àu¾ €‰uüé`  ‹Uj	Yf‰‹ü‹EÌ‹J‰H‹BP‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)‹EÔ3öFj;Æv"X‹ø‹Ş‹EÌÇPÿØ¡A ‹EÔCjYù;Ørç3ÛëY‹}‰uì;Æv>‰Mè‹ƒÀğÁP‹EÌÁPÿÔ¡A ‹ğ‰uü…öˆ¡   ‹Eì‹Mè@jZÊ‰Eì‰Mè;EÔrÈ3öF‹EØ3ÉjZ÷âÁ÷ÙÈQèÜ§ÿÿ‰EĞY…À„JşÿÿÇ ›ıÿÿ9uØv‹G‹L°ü‹EĞ‰°F;uØríSSÿÈ¡A ‹Eğ‹üÿu(ÿu$‹0ÿu ÿuä‹Nÿuÿuhä;@ ÿuàPÿğ¢A ÿV;üt¹   Í)‹ğ‰Eü‹EÌ…Àt)ƒ}Ô vj‹û^ÇPÿÌ¡A ‹EÌCş;]Ôrì‹uüPèf§ÿÿY‹EĞ…ÀtPèX§ÿÿYƒ}ø t	ÿuøÿü¡A ‹Eô…ÀtPÿü¡A ‹Mğ…Ét ‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹uü_‹Æ^[ÉÂ$ Ì‹ÿU‹ìSV‹uW…öu¸@ €ë^‹Mºt;@ è8”ÿÿ‹]…Àu)‹MºÔ;@ è$”ÿÿ…Àu‹MS è”ÿÿ…Àu	!¸@ €ë!‰‹ü‹S‹p‹Îÿğ¢A ÿÖ;üt¹   Í)3À_^[]Â ÌÌÌÌÌ‹ÿU‹ìV‹u‹FH‰Fƒøs‹Îèã÷ÿÿVèg¦ÿÿY3À^]Â ÌÌÌÌÌÌ‹ÿU‹ìV‹uW…öu¸@ €ëO‹U¹Ô;@ è‰“ÿÿ…Àu‹U¹<@ èx“ÿÿ…Àu	!¸@ €ë$‹M‹ü‰Q‹‹p‹Îÿğ¢A ÿÖ;üt¹   Í)3À_^]Â ÌÌÌÌÌÌ‹ÿU‹ì}'  À%õ  H]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ì‹EVW‹ü‹@P‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)_^]Â ‹ÿU‹ìQ‹EVW‹H8…ÉtO‹U;Q$rG‹u2;A,w<EüPVR‹Q ‹Iè5ÿÿ…Àx'‹Eü‹üÿuhd<@ ‹0P‹ÿğ¢A ÿ;üt¹   Í)ë¸@ €_^ÉÂ ÌÌÌÌ‹ÿU‹ì‹EVWƒÀü‹üÿuhD<@ ‹0P‹ÿğ¢A ÿ;üt¹   Í)_^]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹E…Àu¸@ €ëƒ  3À]Â ÌÌÌÌ‹ÿU‹ì3À9E”ÀE@ €]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ìV‹u…öu¸@ €ëOƒ}wD‹EWj\Z‹x0‹Ïèë›ÿÿ…Àuj/Z‹Ïèİ›ÿÿ…Àu‹ÇëƒÀPÿÀ¡A ‰÷Ø_À%òÿø €ë¸W €^]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ìQQS‹]VW…Ûtrƒ} tl‹EMü‹üQhĞ>@ ‹0P‹ÿğ¢A ÿ;üt¹   Í)…Ày¸@ €ë@‹EüMø‹üQP‹0‹Nÿğ¢A ÿV;üt¹   Í)…Àx‹Mø‹A$‰‹A(‹M‰3Àë¸@ €_^[ÉÂ Ì‹ÿU‹ìW‹}…ÿu¸@ €ëF‹E‹U;PDv¸W €ë4V‹p$‹Îƒúr ‹@@SF;ós·ƒÁƒø
uƒêt;Ërì[+ÎÑù3À‰^_]Â Ì‹ÿU‹ì‹E‹PDƒúÿtƒx@ÿt‹M…Ét‰‹M…Ét‹@@‰3Àë¸@ €]Â ÌÌÌÌÌÌÌÌ‹ÿU‹ìƒ} tƒ} ¸@ €u¸@ €]Â Ì‹ÿU‹ìQQ‹MS‹]VW‹}û;y@r‹y@‹E‹÷+ó…Àt‰0j‹ÆZ÷â…Ò‡¹   r	ƒøÿ‡®   ƒ} tP‹A$XPÿuèˆ¦ÿÿƒÄ‹U…Ò„†   63öÑé;ÂÀ÷Ğ#Áv‹ÊjZFf‰I;ğrò‹E‹H8…ÉtX‹Q,‰Uø;ÚwN‹Q$‰Uü;×sD‹@$‹}P‹A ‹HT‹Eü+Ã‹1G‹üP‹Eø+Eüj j PRQ‹Nÿğ¢A ÿV;üt¹   Í)…Àx	3Àë¸€_^[ÉÂ ÌÌ‹ÿU‹ì‹EVW‹ü‹@ÿuÿu‹0P‹ÿğ¢A ÿ;üt¹   Í)_^]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìS‹]V‹ñW…Ûu
¸@ €é‚   ‹}ºD<@ ‹ÏèÑÿÿ…Àu º$<@ ‹ÏèÁÿÿ…ÀuºT<@ ‹Ïè±ÿÿ…ÀtNøëº4<@ ‹Ïèœÿÿ…Àt2Nø÷ÙFüÉ#ÈFø‰‹‹üP‹q‹Îÿğ¢A ÿÖ;üt¹   Í)3Àëƒ# ¸@ €_^[]Â ‹ÿU‹ìƒì ¡@‘A 3Å‰Eø‹ESV‹ñ‰EäWƒ~8 u3ÀëR‹T  EèP3ÛèE  …Àx]è3ÿG9~8u€~0 t3ÿÿuäÿ¢A €=…”A  ‹H  ‹UäWSPtèö  ëèÄ
  ‹Mø_^3Í[è† ÿÿÉÂ 3ÒƒÁ3Àğ±3É…À˜Á‹ÁÃ‹ÿU‹ì‹ES™h  ‹ƒ  VW…Òu4‹T  …ÀtR‹@,‹üSRP‹0‹N(ÿğ¢A ÿV(;üt¹   Í)…Àx&‹‹E‰‹ü‹R‹p‹Îÿğ¢A ÿÖ;üt¹   Í)3À_^[]Â ¸@ €ëò‹ÿU‹ì€y1 t3À@ë‹E‰A‹‰\  Pèa   ]Â ‹ÿU‹ìƒì¡@‘A 3Å‰EüjEôPQÿX¢A ƒøu+€}÷ u%ŠEô<It<iuŠEõ<Mt<muŠEö<Et<eu°ë2À‹Mü3ÍèoŸÿÿÉÃ‹ÿU‹ìV‹ñƒ> u3À@ë!j ÿuh  ÿ6ÿ4¢A ‹F…À~·À  €^]Â ÌÌÌÌÌ‹ÿU‹ìÿuÿP¢A …Àt2‹Mè1   „Àu&j j jÿuÿT¢A j jh   ÿuÿT¢A ‹Eÿ 3À@]Â ‹ÿV‹ñë‹Îèÿÿÿ„ÀuVÿ ¢A ‹ğ…öuè2À^Ã°^Ã‹ÿU‹ìQV‹ñÿvÿ6ÿ¢A ‹Nƒf hşÿ€è¸‰ÿÿƒeü EüPhÀ<A ÿvÿ¢A ƒ}ü uä^ÉÃÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹E‹@,¶@0÷ØÀ%@ €]Â ÌÌÌÌ‹ÿU‹ìQW‹}…ÿu¸@ €ëRSV‹u‹F$;Eu>‹ND…Ét7‹];Y$r/‹Q(‹EQ$Ã;Âw ‹IEüPÿuVüSè­-ÿÿ…Àx‹Eü‰3Àë¸W €^[_ÉÂ ÌÌÌÌ‹ÿU‹ìƒ} VWu¸@ €ë7‹E‹@0‹ˆd  …Éu¸@ €ë ‹‹üÿuQ‹p0‹Îÿğ¢A ÿÖ;üt¹   Í)_^]Â ‹ÿU‹ìQ‹A,Müƒeü SV‹0W‹üQ‹hh>@ Pÿğ¢A ÿ;üt¹   Í)‹Ø…Ûx+‹Eü‹üÿuP‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)‹Ø…Ûx3Û‹Mü…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)_^‹Ã[ÉÂ ÌÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìV‹u…öu¸@ €ë
ÿ$¢A ‰3À^]Â ÌÌÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ìƒ} tƒ} tƒ} ¸@ €u¸@ €]Â ‹ÿU‹ìQS‹ÙMüVW‹ü‹C,QP‹0‹Nÿğ¢A ÿV;üt¹   Í)…Àx)‹C,‹üÿuüP‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)…Àx3À=€u¸ÿÿ€_^[ÉÃ‹ÿU‹ìƒì$‹Á3É‰EäS‰Mô‹@4‰Mü‰Mø‰Mğ‹€d  ‰EèVW…Àu3ÛCéŒ  ‹EMô‹üQh<@ ‹0P‹ÿğ¢A ÿ;üt¹   Í)‹Ø…ÛˆÌ  ‹EôMü‹üQP‹0‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…ÛˆŸ  ƒ}ü …¥   ‹EMì‹üQÿu‹@P‹0‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…Ûˆb  ‹E‹ü‹HEàP‹E@‹1PQ‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…Ûˆ-  ‹UäEü‹üP‹Eà+EìJ‹1Pÿuìÿr(Q‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…Ûˆğ   ‹]èEø‹üPS‹3‹Nÿğ¢A ÿV;üt¹   Í)…ÀyG‹‹üS‹pD‹Îÿğ¢A ÿÖ;üt¹   Í)‹3Eø‹üPS‹Nÿğ¢A ÿV;üt¹   Í)‹Ø…Ûˆ‚   ‹EøMğ‹üQht<@ ‹0P‹ÿğ¢A ÿ;üt¹   Í)‹Ø…ÛxV‹Eğ‹üÿuüP‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)‹Ø…Ûx-‹EèMÜ‹üQj‹0P‹NHÿğ¢A ÿVH;üt¹   Í)‹Ø…Ûx3Û‹Mô…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹Mü…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹Mø…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)‹Mğ…Ét‹‹üQ‹p‹Îÿğ¢A ÿÖ;üt¹   Í)_^‹Ã[ÉÂ ÌÌÌÌ‹ÿU‹ì‹EVW‹ü‹H ÿuÿp(‹Q(‹ITÿp$R‹1Q‹Nÿğ¢A ÿV;üt¹   Í)_^]Â Ì‹ÿU‹ì‹UVW…Òu¸@ €ë*‹M‹ü‹A‰‹AP‹‹q‹Îÿğ¢A ÿÖ;üt¹   Í)3À_^]Â ÌÌÌÌÌÌÌÌÌÌÌ‹ÿU‹ì‹M…Éu¸@ €ë
‹EƒÀü‰3À]Â ‹ÿU‹ìƒì‹A‹Q$ƒeô ƒeø ‹@$V4P‹A(MôFPVèò0  …Ày3Àë<‹U‹MôSWƒÏÿ3À;Møs ·ƒÁƒû
u
…ÒtJ4F3À@‹ûëáƒÿuHPVÿĞ¡A _[^ÉÂ ‹ÿU‹ìƒì‹Á‰Uô¹ÿş  ‰EìSf‰Mü‹MV3öW‰1‹Ş‹M‹ş…Ét‰1…Àt3VVVVjÿPVVÿH¡A ‹Ø…Ûuÿh¡A ‹ğ…ö  ·öÎ  €éú  VVÿ0¡A …ÀtÖ@P‰EøèŒ—ÿÿ‰EğY…Àu
¾ €éÒ  Pÿuøÿ0¡A …Àuÿh¡A ‹ğ…ö   ·öÎ  €é’ 